# Mysql 优化

## 数据库设计三范式

​    什么是设计范式
​        设计表的依据，按照这三个范式设计的表不会出现冗余
​    三范式都是哪些
​        第一：任何一张表都应该有主键，并且每一个字段原子性不可再分。
​        第二：建立在第一范式的基础上，所有非主键字段完全依赖主键，不能产生部分依赖。
​            多对多？三张表，关系表两主键
​            t_student 学生表

           sno(PK)    sname        ------------------------
           1          zhansan
           2          lisi
           3          wangwu
```mysql
        -- t_teacher 讲师表
        tno(PK)     tname
        ------------------------
        1          wanglaoshi
        2          lilaoshi
        3          zhanglaoshi

        -- t_student_teacher_relation 学生讲师关系表
        id(PK)      sno         tno
        ---------------------------------
        1           1           3
        2           1           1
        3           2           2
        4           2           3
        5           3           1
        6           3           3

    -- 第三：建立在第二范式的基础上，所有非主键字段直接依赖主键字段，不能产生传递依赖。
        -- 一对多  班级和学生  两张表，多的表加外键

    -- 提醒： 在实际的开发中，以满足客户的需求为主，有时候会拿冗余换执行速度

-- 一对一设计：
    -- 两种方法： 1. 主键共享(主键、外键) ， 2. 外键唯一
```



### 一、为什么要学习Mysql的优化

### 二、查询过慢的原因：

​    有规律速度过慢：用户访问量激增  -  mysql集群



### 四、Mysql查询语句中七个查询命令特征(根据七个查询):

    1. from
        [作用]:     1)、将硬盘上的表文件加载到内存中，生成一个全新的临时表
        ​            2)、定位内存中已经存在的临时表
        [注意]:     1)、在一个查询语句中，第一个执行命令永远都是form
        ​            2)、form定位的是内存中一个临时表，这个临时表必须手动指定表名.

```mysql
2. where
    [作用]:     1)、where命令操作的由form命令生成的临时表
                2)、where循环遍历当前临时表中的每一个数据行，将满足条件的数据行保存到一个全新的临时表中
    [注意]:     由于where每次操作的只是一个数据行，因此在where使用过程中我们是无法使用聚合函数作为判断条件

3. group by
    [作用]:     1)、首先对临时表中数据进行一次排序处理
                2)、然后将其具有相同特征的数据行保存到同一个临时表
    [注意]:     1)、多字段分组，首先分组字段的执行顺序对于我们的查询结构是没有影响的，然后从第二个分组字段开始，操作的临时表示上一个分组字段生成的临时表
                2)、如果select操作临时表是有group by提供的，此时select将遍历group by 生成的每一个临时表在操作具体临时表时，select只会读取指定字段中第一个数据行内容
4. having
    [作用]:     负责将group by生成的临时表中不满足条件的临时表进行行删除
    [注意]:     1)、having命令不能独立出现。只能出现在group by命令的后面
                2)、having命令每次操作的是一个临时表，因此选择判断条件应该来自于聚合函数

5. select
    [作用]:     1)、select操作的临时表，由from或where命令提供的，select会将制定的字段内容读取出来，将读取出来的内容组成一个全新的临时表
                2)、select操作临时表，由group by或having命令提供，此时select将遍历生成的每一个临时表，
                    在操作具体临时表时，select只会读取指定字段中的第一个数据内容。

6. order by
    [作用]:     专门针对select生成的临时表中的数据进行排序，将排序后的内容组成一个全新的临时表.
    [注意]:     1)、如果order by使用的是字段名进行排序时，字段名可以不出现在select生成的临时表
                2)、如果order by使用字段顺序进行排序时，索引位置必须在select查询语句中出现
7. limit
    [作用]:     对临时表中数据进行截取
```

### 五、查询语句的特征

​    1. 七个查询命令中，除了having命令之外，剩下的6个查询命令在执行完毕后都会生成全新的临时表
​    

    2. 七个查询命令中，除了from命令之外，剩下的6个查询命令操作的临时表都是上一个上一个查询命令生成的临时表
    
    3. 在当前的查询命令执行完毕后，mysql自动的将上一个查询命令生成的临时表进行销毁处理，所以在一个查询语句执行完毕后，用户只能看到最后一个查询命令生成的临时表.
    
    4. 在进行多字段分组时，从第二个分组字段开始，操作的临时表是上一个分组字段生成的临时表

### 六、七个查询命令中哪些命令的效率慢

​    1. 执行速度最慢的是：
​       group by     原因：group by执行时首先将临时表中的数据进行排序，然后在进行分组
​    

```mysql
2. order by     原因：需要对select生成的临时表中的数据进行排序，然后将排好顺序的数据行组成一个全新的临时表

3. where        原因：需要对表中所有数据行进行遍历，如果临时表中数据行过多的话，导致where执行效率非常慢

4. limit        原因：如果指定的起始行数过大，导致查询速度的变慢

5. 对于我们多表查询来说如果没有指定表文件加载顺序，也会导致查询速度过慢
```

### 七、查询命令执行过慢的原因

​    1. 执行时需要对所有的数据进行排序
​    

    2. 执行时需要对表中所有数据进行遍历
    
    3. I/O流加载表文件的次数

### 八、索引的介绍

    1. 定义：索引存在于对应的索引文件中，索引的本质是一组排好了顺序的一组数据
        2. 作用：
        1)、 在索引数据中进行排序时候，避免再次排序
        2)、 在索引数据中对我们的数据行进行定位时，避免对全表扫描
        3. 索引文件的位置
        1)、 如果当前表依赖于INNODB存储引擎，索引存在FRM文件
        2)、 如果当前表依赖MYISAM存储引擎，索引存在MYI文件
        4. 索引的基本操作
        1)、 查看 
